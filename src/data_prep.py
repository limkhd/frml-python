"""data_prep.py
====================
Module performing data loading and formatting to model input
"""

import logging
import scipy.io as s
import frml_python.label_utils

# Init logger
logger = logging.getLogger(__name__)

# Keys in the .mat file
fold_keys = ["Yval", "Ytrain", "Ytest", "Ktrain", "Kval", "Ktest"]


def load_folds(filename):
    """Loads Imagenet 300 data from a .mat file in a nested dictionary format

    Parameters
    ----------
    filename : str
        File pointing to .mat file containing the data

    Returns
    -------
    output : list
        A list of 5 folds (objects) where each fold is a dictionary containing the keys
        "Xval", "Xtrain", "Xtest", "Ytrain", "Yval", "Ytest".
        where each key is a numpy.ndarray containing the underlying features.
        Specifically, Xval, Xtrain, Xtest are :math:`n_{split} \\times d` arrays
        where :math:`n_{split}` is the number of examples in each split while Yval,
        Ytrain, Ytest are 1-dimensional integer arrays with each element in
        {1, 2, 3, 4} encoding class membership.

    """
    folds = s.loadmat(filename)

    fold_list = []

    # Extract the train, test, validation sets for each fold
    for foldnum in range(5):
        fold_data = folds["folds"][0][foldnum]
        fold_dict = {
            **{
                "X%s" % key: fold_data["K%s" % key].T
                for key in ["train", "test", "val"]
            },
            **{
                "Y%s" % key: fold_data["Y%s" % key].flatten()
                for key in ["train", "test", "val"]
            },
        }

        fold_list.append(fold_dict)

    return fold_list


def get_ranking_labeled_ML_obj(folds, foldnum, train_k=None):
    """Convert multiclass labeled data in `folds` to a binary relevance format
    where each training example will have similar and dissimilar examples in the
    training set.


    Parameters
    ----------
    folds : list
        Generated by `data_prep.load_folds()`. See documentation for details

    foldnum : int
        Takes a value from 0-4 as there are 5 folds.

    train_k : int
        Number of similar examples to include in the label for each training point.
        For example, if x[0] is similar to x[2], x[3], x[7] (same class) and `train_k` = 2,
        we will only put two similar examples (e.g. x[2], x[3]) in the label for x[0].

    Returns
    -------
    output : list
        A list of 5 folds (objects) where each fold is a dictionary containing the keys
        "Xval", "Xtrain", "Xtest", "Ytrain", "Yval", "Ytest".
        where each key is a numpy.ndarray containing the underlying features.
        Specifically, Xval, Xtrain, Xtest are :math:`n_{split} \\times d` arrays
        where n is the number of examples in each split while Yval, Ytrain, Ytest
        are lists of `RankingLabel` namedtuples defined in `frml_python.label_utils`

    """

    output = {}

    Xtrain = folds[foldnum]["Xtrain"]
    Xval = folds[foldnum]["Xval"]
    Xtest = folds[foldnum]["Xtest"]

    Ytrain = folds[foldnum]["Ytrain"]
    Yval = folds[foldnum]["Yval"]
    Ytest = folds[foldnum]["Ytest"]

    logger.info("Generating training ranking labels")
    (
        Xtrain_,
        Ytrain_,
    ) = frml_python.label_utils.generate_training_ranking_labels_from_class(
        Xtrain, Ytrain, k=train_k
    )
    logger.info("Generating validation ranking labels")
    Xval_, Yval_ = frml_python.label_utils.generate_test_ranking_labels_from_class(
        Xval, Yval, Xtrain, Ytrain
    )
    logger.info("Generating test ranking labels")
    Xtest_, Ytest_ = frml_python.label_utils.generate_test_ranking_labels_from_class(
        Xtest, Ytest, Xtrain, Ytrain
    )

    output["Xtrain"] = Xtrain_
    output["Xtest"] = Xtest_
    output["Xval"] = Xval_
    output["Ytrain"] = Ytrain_
    output["Ytest"] = Ytest_
    output["Yval"] = Yval_

    return output
